#include "doConfig.h"
#include "doMesh.h"

//std::vector<Quadrature_point<T>> qpoints;

template <typename T>
void Triangle<T>::setQuadrature(int degree){
	Node<T>* p1=this->node_ptrs[0];
	Node<T>* p2=this->node_ptrs[1];
	Node<T>* p3=this->node_ptrs[2];
	switch (degree){
		case 1:{
			T a[] = { 0.3333333333333333 };
			T b[] = { 0.3333333333333333 };
			T c[] = { 0.3333333333333333 };
			T w[] = { 1.0 };
			for (int i = 0; i < 1; ++i) {
				T x=a[i]*p1->x + b[i]*p2->x + c[i]*p3->x;
				T y=a[i]*p1->y + b[i]*p2->y + c[i]*p3->y;
				T z=a[i]*p1->z + b[i]*p2->z + c[i]*p3->z;
				Quadrature_point<T> p={x,y,z,w[i]};
				this->qpoints.push_back(p);
			}
			break;
		}
		case 2:{
			T a[] = { 0.666666666666667,0.166666666666667,0.166666666666667 };
			T b[] = { 0.166666666666667,0.166666666666667,0.666666666666667 };
			T c[] = { 0.166666666666666,0.666666666666667,0.166666666666667 };
			T w[] = { 0.3333333333333333, 0.3333333333333333, 0.3333333333333333 };
			for (int i = 0; i < 3; ++i) {
				T x=a[i]*p1->x + b[i]*p2->x + c[i]*p3->x;
				T y=a[i]*p1->y + b[i]*p2->y + c[i]*p3->y;
				T z=a[i]*p1->z + b[i]*p2->z + c[i]*p3->z;
				Quadrature_point<T> p={x,y,z,w[i]};
				this->qpoints.push_back(p);
			}
			break;
		}
		case 3:{
			T a[] = { 0.3333333333333333,0.6,0.2,0.2 };
			T b[] = { 0.3333333333333333,0.2,0.2,0.6 };
			T c[] = { 0.3333333333333333,0.2,0.6,0.2 };
			T w[] = { -0.5624999999999998, 0.5208333333333333, 0.5208333333333333, 0.5208333333333333 };
			for (int i = 0; i < 4; ++i) {
				T x=a[i]*p1->x + b[i]*p2->x + c[i]*p3->x;
				T y=a[i]*p1->y + b[i]*p2->y + c[i]*p3->y;
				T z=a[i]*p1->z + b[i]*p2->z + c[i]*p3->z;
				Quadrature_point<T> p={x,y,z,w[i]};
				this->qpoints.push_back(p);
			}
			break;
		}
		case 4:{
			T a[] = { 0.8168475729804585,0.0915762135097707,0.0915762135097707,0.1081030181680702,0.4459484909159649,0.4459484909159649 };
			T b[] = { 0.0915762135097707,0.0915762135097707,0.8168475729804585,0.4459484909159649,0.4459484909159649,0.1081030181680702 };
			T c[] = { 0.0915762135097707,0.8168475729804585,0.0915762135097707,0.4459484909159649,0.1081030181680702,0.4459484909159649 };
			T w[] = { 0.1099517436553219, 0.1099517436553219, 0.1099517436553219, 0.2233815896780115, 0.2233815896780115, 0.2233815896780115 };
			for (int i = 0; i < 6; ++i) {
				T x=a[i]*p1->x + b[i]*p2->x + c[i]*p3->x;
				T y=a[i]*p1->y + b[i]*p2->y + c[i]*p3->y;
				T z=a[i]*p1->z + b[i]*p2->z + c[i]*p3->z;
				Quadrature_point<T> p={x,y,z,w[i]};
				this->qpoints.push_back(p);
			}
			break;
		}
		case 5:{
			T a[] = { 0.3333333333333333,0.0597158717897698,0.4701420641051151,0.4701420641051151,0.7974269853530873,\
			0.1012865073234563,0.1012865073234563 };
			T b[] = { 0.3333333333333333,0.4701420641051151,0.4701420641051151,0.0597158717897698,0.1012865073234563,\
			0.1012865073234563,0.7974269853530873 };
			T c[] = { 0.3333333333333333,0.4701420641051151,0.0597158717897698,0.4701420641051151,0.1012865073234563,\
			0.7974269853530873,0.1012865073234563 };
			T w[] = { 0.2250000000000002, 0.1323941527885061, 0.1323941527885061, 0.1323941527885061, 0.1259391805448272, \
			0.1259391805448272, 0.1259391805448272 };
			for (int i = 0; i < 7; ++i) {
				T x=a[i]*p1->x + b[i]*p2->x + c[i]*p3->x;
				T y=a[i]*p1->y + b[i]*p2->y + c[i]*p3->y;
				T z=a[i]*p1->z + b[i]*p2->z + c[i]*p3->z;
				Quadrature_point<T> p={x,y,z,w[i]};
				this->qpoints.push_back(p);
			}
			break;
		}
		case 6:{
			T a[] = { 0.5611400349004341,0.2194299825497830,0.2194299825497830,0.0397240717755698,0.4801379641122151,\
			0.4801379641122151,0.0193717243612408,0.1416190159239682,0.8390092597147911,0.1416190159239682,0.0193717243612408,0.8390092597147911 };
			T b[] = { 0.2194299825497830,0.2194299825497830,0.5611400349004341,0.4801379641122151,0.4801379641122151,\
			0.0397240717755698,0.1416190159239682,0.8390092597147911,0.0193717243612408,0.0193717243612408,0.8390092597147911,0.1416190159239682 };
			T c[] = { 0.2194299825497830,0.5611400349004341,0.2194299825497830,0.4801379641122151,0.0397240717755698,\
			0.4801379641122151,0.8390092597147911,0.0193717243612408,0.1416190159239682,0.8390092597147911,0.1416190159239682,0.0193717243612408 };
			T w[] = { 0.1713331241529811, 0.1713331241529811, 0.1713331241529811, 0.0807310895930309, 0.0807310895930309, \
			0.0807310895930309, 0.0406345597936607, 0.0406345597936607, 0.0406345597936607, 0.0406345597936607, 0.0406345597936607, 0.0406345597936607 };
			for (int i = 0; i < 12; ++i) {
				T x=a[i]*p1->x + b[i]*p2->x + c[i]*p3->x;
				T y=a[i]*p1->y + b[i]*p2->y + c[i]*p3->y;
				T z=a[i]*p1->z + b[i]*p2->z + c[i]*p3->z;
				Quadrature_point<T> p={x,y,z,w[i]};
				this->qpoints.push_back(p);
			}
			break;
		}
		case 7:{
			T a[] = { 0.3333333333333333,0.4793080678419204,0.2603459660790398,0.2603459660790398,0.8697397941955683,\
			0.0651301029022158,0.0651301029022158,0.0486903154253163,0.6384441885698098,0.3128654960048739,0.6384441885698098,0.0486903154253163,0.3128654960048739 };
			T b[] = { 0.3333333333333333,0.2603459660790398,0.2603459660790398,0.4793080678419204,0.0651301029022158,\
			0.0651301029022158,0.8697397941955683,0.6384441885698098,0.3128654960048739,0.0486903154253163,0.0486903154253163,0.3128654960048739,0.6384441885698098 };
			T c[] = { 0.333333333333333,0.260345966079040,0.479308067841920,0.260345966079040,0.065130102902216,\
			0.869739794195568,0.065130102902216,0.312865496004874,0.048690315425316,0.638444188569810,0.312865496004874, 0.638444188569810,0.048690315425316 };
			T w[] = { -0.1495700444676828,0.1756152574332084,0.1756152574332084,0.1756152574332084,0.0533472356088385,0.0533472356088385,\
			0.0533472356088385,0.0771137608902570,0.0771137608902570,0.0771137608902570,0.0771137608902570,0.0771137608902570,0.0771137608902570 };
			for (int i = 0; i < 13; ++i) {
				T x=a[i]*p1->x + b[i]*p2->x + c[i]*p3->x;
				T y=a[i]*p1->y + b[i]*p2->y + c[i]*p3->y;
				T z=a[i]*p1->z + b[i]*p2->z + c[i]*p3->z;
				Quadrature_point<T> p={x,y,z,w[i]};
				this->qpoints.push_back(p);
			}
			break;
		}
		default:{
			std::cout << "Error: the quadrature degree of "<<degree<< " has not been defined." <<std::endl;
			logfile << "Error: the quadrature degree of "<<degree<< " has not been defined." <<std::endl;
			}
	}
}
template void Triangle<double>::setQuadrature(int degree);
template void Triangle<float>::setQuadrature(int degree);

template <typename T>
void Quadrilateral<T>::setQuadrature(int degree){
	Node<T>* p1=this->node_ptrs[0];
	Node<T>* p2=this->node_ptrs[1];
	Node<T>* p3=this->node_ptrs[2];
	Node<T>* p4=this->node_ptrs[3];
	switch (degree){
		case 1:{
			T a[] = { 0.25 };
			T b[] = { 0.25 };
			T c[] = { 0.25 };
			T d[] = { 0.25 };
			T w[] = { 1.0 };
			for (int i = 0; i < 1; ++i) {
				T x=a[i]*p1->x + b[i]*p2->x + c[i]*p3->x + d[i]*p4->x;
				T y=a[i]*p1->y + b[i]*p2->y + c[i]*p3->y + d[i]*p4->y;
				T z=a[i]*p1->z + b[i]*p2->z + c[i]*p3->z + d[i]*p4->z;
				Quadrature_point<T> p={x,y,z,w[i]};
				this->qpoints.push_back(p);
			}
			break;
		}
		default:{
			std::cout << "Error: the quadrature degree of "<<degree<< " has not been defined." <<std::endl;
			logfile << "Error: the quadrature degree of "<<degree<< " has not been defined." <<std::endl;
			}
	}
}
template void Quadrilateral<double>::setQuadrature(int degree);
template void Quadrilateral<float>::setQuadrature(int degree);
